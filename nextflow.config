apptainer.enabled = true

params {
    sampleFileSep = "\t"
    humid = null

    general {

        hichContainer = "bskubi/hich:latest"
        chromsizesContainer = 'quay.io/biocontainers/ucsc-fasize:332--0'
        mustacheContainer = "bskubi/mustache:latest"
        juicerContainer = "bskubi/juicer_tools:1.22.01"
        hictkContainer = "ghcr.io/paulsengroup/hictk:1.0.0"

        publish {
            // Nextflow publishDir param for all processes
            // https://www.nextflow.io/docs/latest/process.html#publishdir
            mode = "copy"

            // Where to publish results of Hich processes
            genomeReference = "resources/hich/genomeReference"
            chromsizes = "resources/hich/chromsizes"
            bwaMem2Index = "resources/hich/bwa-mem2"
            bwaIndex = "resources/hich/bwa"
            bsboltIndex = "resources/hich/bsbolt"
            fragmentIndex = "resources/hich/fragmentIndex"

            align = "results/align"
            parse = "results/pairs/parse"
            dedup = "results/pairs/dedup"
            mcool = "results/matrix/mcool"
            hic = "results/matrix/hic"
            pairStats = "results/pairStats"
            qc = "results/qc"
        }
        
        // After these steps, generate read-level pairs 
        // stats files and generate a combined MultiQC report
        // for all samples at each processing stage
        qcAfter = ["parse",
                    "ingestPairs",
                    "tagRestrictionFragments",
                    "deduplicate",
                    "select"]
        
        // Number of reads to downsample to by default for a humid run
        // can also be specified simply via --humid 100000 or similar
        humidDefault = 100000
    }

    sampleSelectionStrategies {
        fairComparisons {
            same = ["aggregateProfileName", "aggregateLevel"]
            different = ["id"]
            aggregateProfileName = "p1"

        }

        techrepsOnly {
            aggregateLevel = "techrep"
        }

        biorepsOnly {
            aggregateLevel = "biorep"
        }

        biorep1 {
            biorep = "1"
        }

        biorep2 {
            biorep = "2"
        }

        conditionsOnly {
            aggregateLevel = "condition"
        }

        fullCoverage {
            aggregateProfileName = "pt1"
        }
    }

    hicrep {
        testHicrep100kb_br1 {
            resolutions = [100000]
            chroms = ["chr20", "chr21", "chr22"]
            h = 1
            dBPMax = 5000000
            bDownSample = false
            sampleSelectionStrategy = ["techrepsOnly", "biorep1"]
        }

        testHicrep100kb_br2 {
            resolutions = [100000]
            chroms = ["chr20", "chr21", "chr22"]
            h = 1
            dBPMax = 5000000
            bDownSample = false
            sampleSelectionStrategy = ["techrepsOnly", "biorep2"]
        }
    }

    compartments {
        testSelectionStrategy100kb {
            sampleSelectionStrategy = ["techrepsOnly"]
            resolution = 100000
            hichCompartmentsParams = [
                "--n_eigs 3"
            ]
        }
    }

    insulation {
        testSelectionStrategy100kbBigwig {
            sampleSelectionStrategy = ["fullCoverage"]
            
            resolution = 100000
            cooltoolsInsulationParams = [
                "--bigwig"
            ]
            window = 100000
        }
    }

    loops {
        fairConditions_Chr22_1Mb {
            sampleSelectionStrategy = ["fullCoverage"]

            // Parameters for mustache loop calling
            mustacheParams = [
            "--resolution 100000",
            "--chromosome chr22",
            "--pThreshold .1",
            "--sparsityThreshold .88"
            ]
        }
    }

    differentialLoops {
        fairConditions_Chr22_1Mb {
                sampleSelectionStrategy = ["fairComparisons", "fullCoverage"]

                // Parameters for mustache loop calling
                mustacheParams = [
                "--resolution 100000",
                "--chromosome chr22",
                "--pThreshold .1",
                "--sparsityThreshold .88"
                ]
        }
    }

    aggregate {
        pt1 {
            dedupSingleCell = false
            dedupMaxMismatch = 3
            dedupMethod = 'max'
            techrepDedup = true
            techrepDownsampleToMeanDistribution = true
            techrepCisStrata = [10, 20, 50, 100, 200, 500, 1000, 2000, 5000, 10000, 20000, 50000]
        }
        pt75 {
            dedupSingleCell = false
            dedupMaxMismatch = 3
            dedupMethod = 'max'
            techrepDedup = true
            techrepDownsampleToSize = .75
            techrepDownsampleToMeanDistribution = true
            techrepCisStrata = [10, 20, 50, 100, 200, 500, 1000, 2000, 5000, 10000, 20000, 50000]
        }
        pt5 {
            dedupSingleCell = false
            dedupMaxMismatch = 3
            dedupMethod = 'max'
            techrepDedup = true
            techrepDownsampleToSize = .5
            techrepDownsampleToMeanDistribution = true
            techrepCisStrata = [10, 20, 50, 100, 200, 500, 1000, 2000, 5000, 10000, 20000, 50000]
        }
        pt25 {
            dedupSingleCell = false
            dedupMaxMismatch = 3
            dedupMethod = 'max'
            techrepDedup = true
            techrepDownsampleToSize = .25
            techrepDownsampleToMeanDistribution = true
            techrepCisStrata = [10, 20, 50, 100, 200, 500, 1000, 2000, 5000, 10000, 20000, 50000]
        }
    }

    defaults {
        techrep = 1
        biorep = 1
        minMapq = 1


        
        /*
           Note: Do not include a default sample datatype.
           The datatype is inferred during sample ingestion.
        */
        
        aligner = "bwa-mem2"
        bwaFlags = "-SP5M"

        /*
           Default for extracting the cell barcode for each read and putting it in the column cellID.
           This is done with `hich reshape`. Defaults are only applied for a given sample if
           cellBarcodeField is specified  and there is no cellBarcodeRegexPattern or cellBarcodeParsePattern.
           If cellBarcodeField is readID and --drop-readid is specified, then the readID column is dropped
           AFTER parsing and reshaping, the last action taken by hich reshape.

           Note that globalDefaultReshapeToCellID should not be used in id-specific ConfigMap bundles.
           Specify a value of reshapeParams instead for id-specific ConfigMap bundles.

           Note that parsing the cellBarcodeField to the cellID column happens first, before any other reshapeParams
           options are applied. For more control over the order of hich reshape flags, specify id-specific reshapeParams
           ConfigMap bundles in params, after the params.defaults ConfigMap bundle.

           Also, note that patterns (regex and parse) will be automatically wrapped in quotes
           when processed during UpdateSamples.
        */
         
        reshapeParams = []
        globalDefaultReshapeToCellID = ["option":"--regex", "pattern":"^(.*?):.*", "group":1]

        pairsFormat {
            chrom1 = 2
            pos1 = 3
            chrom2 = 4
            pos2 = 5
        }

        parseParams = [
           "--flip",
           "--min-mapq 1",
           "--drop-readid",
           "--drop-seq",
           "--drop-sam"
        ]

        reshapeParams = []

        pairtoolsDedupParams = []

        pairtoolsSelectParams = []
            
        selectFilters {
            keepPairTypes = ["UU", "RU", "UR"]
            keepTrans = true
            keepCis = true
            minDistFR = 1000
            minDistRF = 1000
            minDistFF = 1000
            minDistRR = 1000

            chroms = ["chr1", "chr2", "chr3", "chr4", "chr5", "chr6",
                        "chr7", "chr8", "chr9", "chr10", "chr11", "chr12",
                        "chr13", "chr14", "chr15", "chr16", "chr17", "chr18",
                        "chr19", "chr20", "chr21", "chr22", "chrX"]
            
            discardSingleFrag = true
        }

        juicerToolsPreParams = []

        coolerCloadParams = []

        coolerZoomifyParams = [
            "--balance",
            "--balance-args '--max-iters 2000 --trans-only'"
        ]

        matrix {
            makeMcoolFileFormat = true
            makeHicFileFormat = false
            resolutions = [100000]
        }    
    }

    // Create id-specific bundles starting here. Any samples matching the ids list
    // for a particular bundle will have their previous values (specified in sample file or by the defaults
    // second) replaced by the values here. Multiple id-specific bundles can be created.
    // Each must have a name preceding {},
    // and list the ids to which they apply as ids = [sample ids].
    // This is an empty ConfigMap bundle as a starting point.
    // These are applied during the UpdateSamples workflow in setup.nf
    emptyBundle {
        ids = []
    }

    hichContainer = "bskubi/hich:latest"
}

profiles {
    localPC {
        executor.name = 'local'
        executor.cpus = 10
        executor.memory = 20.GB
        process.executor = 'local'
        
        process {
            withLabel: whenLocal_allConsuming {
                maxForks = 1
                cpus = 10
                memory = 20.GB
            }

            withLabel: convertHicToMcool {
                cpus = 2
            }

            withLabel: convertMcoolToHic {
                cpus = 20
            }

            withLabel: features {
                cpus = 5
                memory = 10.GB

            }
        }

    }

    localHPC {
        executor.name = 'local'
        executor.cpus = 100
        executor.memory = 200.GB
        process.executor = 'local'

        process {
            withLabel: whenLocal_allConsuming {
                maxForks = 1
                cpus = 100
                memory = 200.GB
            }

            withLabel: convertMcoolToHic {
                cpus = 20
            }
        }

    }

    jobArray {
        process {
            withLabel: doJobArray {
                array = 20
            }
        }
    }

    grid {
        process {
            withLabel: align {
                time = '36hr'
                cpus = 24
            }

            withLabel: index {
                time = '36hr'
                cpus = 24
            }

            withLabel: smallResource {
                time = '4hr'
                cpus = 8
                memory = 8.GB
            }

            withLabel: pairs {
                time = '16hr'
                cpus = 8
                memory = 8.GB
            }

            withLabel: createMatrix {
                time = '36hr'
                cpus = 8
                memory = 16.GB
            }

            withLabel: convertHicToMcool {
                cpus = 2
                memory = 8.GB
            }

            withLabel: convertMcoolToHic {
                cpus = 20
                memory = 8.GB
            }
        }
    }
}
